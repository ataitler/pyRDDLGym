////////////////////////////////////////////////////////////////////
// A simple continuous MDP for the classical cart-pole system by Rich
// Sutton. 
//
// The goal here is to push a cart on a flat and frictionless surface 
// left or right by applying a constant force, in order to balance a 
// pole balanced vertically in the center of the cart.
//
////////////////////////////////////////////////////////////////////
domain cart_pole {

    requirements = {
        reward-deterministic
    };

    pvariables {

    	// forces
		GRAVITY   : { non-fluent, real, default = 9.8 };        // force of gravity acting down
		FORCE-MAG : { non-fluent, real, default = 10.0 };		// force applied to the side of the cart

		// cart and pole properties
		CART-MASS : { non-fluent, real, default = 1.0 };        // mass of the cart
		POLE-MASS : { non-fluent, real, default = 0.1 };		// mass of the pole
		POLE-LEN  : { non-fluent, real, default = 0.5 }; 		// half of the pole length
		
		// other constants
		TIME-STEP : { non-fluent, real, default = 0.02 }; 		// seconds between state updates
		POS-LIMIT : { non-fluent, real, default = 2.4 };		// limit of cart position
		ANG-LIMIT : { non-fluent, real, default = 0.2094395 };	// limit of pole angle
	
		// interm & derived fluents
		force : { interm-fluent, real };                       // actual signed force applied to the cart
		temp : { interm-fluent, real };						// temporary variable
		acc : { interm-fluent, real };							// position acceleration
		ang-acc : { interm-fluent, real };						// angular acceleration
		out-of-bounds : { interm-fluent, bool };				// whether the system is out of bounds
		increment : { interm-fluent, real };					// actual state increment accounting for out of bounds
		
		// states
       	pos    	: { state-fluent, real, default = 0 };          // cart position
       	ang-pos	: { state-fluent, real, default = 0 };          // pole angle
       	vel   	: { state-fluent, real, default = 0 };          // cart velocity
       	ang-vel : { state-fluent, real, default = 0 };          // pole angular velocity

       	// actions
       	force-side : { action-fluent, int, default = 0 };      	// whether to apply force to left, right side or none
       	//test : { action-fluent, bool, default = false };      	// whether to apply force to left, right side or none
    };

    cpfs {
		// the actual signed force on the cart
		force = if(force-side == 1)
				 then FORCE-MAG
				 else -FORCE-MAG;
		
		// compute the pole angular acceleration
		temp = (force + POLE-LEN * pow[ang-vel, 2] * sin[ang-pos]) / (CART-MASS + POLE-MASS);
		ang-acc = (GRAVITY * sin[ang-pos] - cos[ang-pos] * temp) / (
            POLE-LEN * ((4.0 / 3.0) - (POLE-MASS * pow[cos[ang-pos], 2] / (CART-MASS + POLE-MASS))));
		
		// compute the cart acceleration
		acc = temp - (POLE-LEN * ang-acc * cos[ang-pos] / (CART-MASS + POLE-MASS));
		
		// out of bounds checks
		out-of-bounds = (pos <= -POS-LIMIT) | (pos >= POS-LIMIT) | (ang-pos <= -ANG-LIMIT) | (ang-pos >= ANG-LIMIT);
		
		// if out of bounds, do not update the state
		increment = if(out-of-bounds)
						then 0.0
						else TIME-STEP;

		// Euler integration formula
		pos' = max[min[pos + increment * vel, POS-LIMIT], -POS-LIMIT];
		ang-pos' = max[min[ang-pos + increment * ang-vel, ANG-LIMIT], -ANG-LIMIT];
		vel' = vel + increment * acc;
		ang-vel' = ang-vel + increment * ang-acc;
    };

    // R = 1 as long as the pole is upright and the cart is not out of bounds
    reward = if(out-of-bounds)
				then 0.0
				else 1.0;

    state-invariants {
		pos >= -POS-LIMIT ^ pos <= POS-LIMIT;
		ang-pos >= -ANG-LIMIT ^ ang-pos <= ANG-LIMIT;
    };

    action-preconditions {
        force-side <= 1;
        force-side >= 0;
    };

}
