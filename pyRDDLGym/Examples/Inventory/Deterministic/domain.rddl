// Simple linear continuous inventory control problem

domain inventory {

	types {
		item : object;
	};

	pvariables {

		PURCHASE-COST(item) : { non-fluent, real, default = 1.0 };
		PRICE(item)         : { non-fluent, real, default = 2.0 };
		MAX-ITEMS           : { non-fluent, int, default = 10 };
		MIN-DEMAND(item) : { non-fluent, int, default = 0 }; 		
		MED-DEMAND(item) : { non-fluent, int, default = 2 };		
		MAX-DEMAND(item) : { non-fluent, int, default = 4 };
		P-MIN(item) : { non-fluent, real, default = 0.25 };
		P-MED(item) : { non-fluent, real, default = 0.6 };
		
		raw-demand(item) : { interm-fluent, int }; 
			
		stock(item) : { state-fluent, int, default = 0 };
	
		order(item) : { action-fluent, int, default = 0 };
	};

	cpfs {	
		raw-demand(?i) = floor[P-MIN(?i) * MIN-DEMAND(?i) 
								+ (1 - P-MIN(?i)) * P-MED(?i) * MED-DEMAND(?i) 
								+ (1 - P-MIN(?i)) * (1 - P-MED(?i)) * MAX-DEMAND(?i)];
		stock'(?i) = max[0, stock(?i) + order(?i) - raw-demand(?i)];
	};

	reward = (sum_{?i : item} [PRICE(?i) * (stock(?i) + order(?i) - stock'(?i)) - PURCHASE-COST(?i) * order(?i)]);

	action-preconditions {
		forall_{?i : item} [ order(?i) >= 0 ];
		(sum_{?i : item} order(?i)) <= MAX-ITEMS;
	};
	
	state-invariants {
		forall_{?i : item} [ stock(?i) >= 0 ];
	};
}