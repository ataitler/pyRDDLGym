// Simple linear inventory control problem
// Taken from Bertsekas, Dynamic Programming and Optimal Control, Vol. 1, 3rd Ed., Section 4.2

domain inventory{

	types {
		item : object;
	};

	pvariables {

		// constants
		HOLDING-COST(item) : { non-fluent, real, default = 2.0 };		// holding cost for excess inventory
		SHORTAGE-COST(item) : { non-fluent, real, default = 4.0 };	// shortage cost for inadequate inventory
		PURCHASE-COST(item) : { non-fluent, real, default = 1.0 };  // purchase price of unit
		MAX-ITEMS(item) : { non-fluent, int, default = 50 };       // max number of items that can be held
		MAX-ORDER : { non-fluent, int, default = 6 };             // max number of items that can be ordered
		MAX-BACKLOG(item) : { non-fluent, int, default = -50 };    // max number of items that can be backlogged
		DEMAND-RATE(item) : { non-fluent, real, default = 2.0 };   // Poisson rate of demand
		
		// iterm fluent
		demand(item) : { interm-fluent, int }; // demand in current epoch
		
		// states
		stock(item) : { state-fluent, int, default = 0 };   // stock on hand at beginning of epoch
	
		// actions
		order(item) : { action-fluent, int, default = 0 };    // how many units to purchase
	};

	cpfs {
		demand(?i) = Poisson(DEMAND-RATE(?i));
		stock'(?i) = max[MAX-BACKLOG(?i), min[MAX-ITEMS(?i), stock(?i) + order(?i) - demand(?i)]];
	};

	reward = -(sum_{?i : item} [SHORTAGE-COST(?i) * max[0, -stock'(?i)] 
								+ HOLDING-COST(?i) * max[0, stock'(?i)] 
								+ PURCHASE-COST(?i) * order(?i)]);

	action-preconditions {
		forall_{?i : item} [ order(?i) >= 0 ];
		forall_{?i : item} [ order(?i) <= MAX-ORDER ];
		(sum_{?i : item} order(?i)) <= MAX-ORDER;
	};
	
	state-invariants {
		forall_{?i : item} [ stock(?i) >= MAX-BACKLOG(?i) ];
		forall_{?i : item} [ stock(?i) <= MAX-ITEMS(?i) ];
		forall_{?i : item} [ PURCHASE-COST(?i) > 0 ];
		forall_{?i : item} [ SHORTAGE-COST(?i) > PURCHASE-COST(?i) ];
	};
}