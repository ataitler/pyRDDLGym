domain reservoir_control_linear {
	
	requirements = { 
		reward-deterministic 
	};

	types {
		id: object;
	};
	
	pvariables {
	
		// Constant
		MAXCAP(id) : { non-fluent, real, default = 100.0 };
		HIGH_BOUND(id) : { non-fluent, real, default = 80.0 };
		LOW_BOUND(id) : { non-fluent, real, default = 20.0 };
		HIGH_COST(id) : { non-fluent, real, default = -100.0 };
		LOW_COST(id) : { non-fluent, real, default = -5.0 };
		RAIN_MEAN(id) : { non-fluent, real, default = 5.0 };
		RAIN_VAR(id) : { non-fluent, real, default = 5.0 };
		DOWNSTREAM(id, id) : { non-fluent, bool, default = false };
		
		rainfall(id) : { interm-fluent, real };
		
		rlevel(id): { state-fluent, real, default = 50.0 };
		
		release(id): { action-fluent, real, default = 0.0 };
	};
	
	cpfs {
		rainfall(?r) = max[0, Normal(RAIN_MEAN(?r), RAIN_VAR(?r))];
		
		rlevel'(?r) = max[0, min[MAXCAP(?r), 
			rlevel(?r) + rainfall(?r) - release(?r) + (sum_{?r2: id}[DOWNSTREAM(?r2, ?r) * release(?r2)])]];
	};
	
	reward = (sum_{?r: id} [LOW_COST(?r) * max[LOW_BOUND(?r) - rlevel'(?r), 0]
							+ HIGH_COST(?r) * max[rlevel'(?r) - HIGH_BOUND(?r), 0]]);
	
	action-preconditions {
		forall_{?r: id} [release(?r) <= rlevel(?r)];
		forall_{?r: id} [release(?r) >= 0];
	};
	
	state-invariants {	
		forall_{?r: id} [rlevel(?r) >= 0];
		forall_{?r: id} [rlevel(?r) <= MAXCAP(?r)];
	};
}