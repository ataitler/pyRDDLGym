////////////////////////////////////////////////////////////////////
// A simple continuous MDP for the racecar problem.
//
// A car is accelerated by applying a force in the x and y directions. 
// The goal is to bring the car to within a fixed distance to a fixed 
// goal location. The car must remain within boundaries defined as 
// line segments connected between points (X1, Y1) and (X2, Y2).
// 
// Obstacles are defined as shapes (including the track), which the car
// must avoid and is reset to its initial state if it comes into contact
// with one.
//
////////////////////////////////////////////////////////////////////
domain racecar {
	
    requirements = {
        reward-deterministic
    };
	
	types {
		shape: object;          // each shape in the world map, including the track and any obstacles within
		boundary: object;		// boundary of each object given as line segments
	};
	
    pvariables {
		
		// non-fluents
		X1(shape, boundary) 	: { non-fluent, real, default = 0 };	 	// boundary is the line segment (X1, Y1) -> (X2, Y2)
		Y1(shape, boundary) 	: { non-fluent, real, default = 0 };	
		X2(shape, boundary) 	: { non-fluent, real, default = 1 };
		Y2(shape, boundary) 	: { non-fluent, real, default = 1 };
		
		X0		: { non-fluent, real, default = 0.01 };		// starting x position of car
		Y0 		: { non-fluent, real, default = 0.01 };		// starting y position of car
		
		GX 			: { non-fluent, real, default = 0.95 };		// x center of goal region
		GY 			: { non-fluent, real, default = 0.95 };		// y center of goal region
		RADIUS 		: { non-fluent, real, default = 0.05 };		// radius of goal region
		COST 		: { non-fluent, real, default = 0.01 };		// cost of fuel, proportional to force	
		GOAL-REWARD : { non-fluent, real, default = 1.0 };		// reward upon reaching the goal region
		
		MAX-F 	: { non-fluent, real, default = 1 };		// maximum force in each direction 
		MASS 	: { non-fluent, real, default = 1 };		// mass of the car
		DT	 	: { non-fluent, real, default = 0.1 };		// how much time passes between epochs	
		
		// interm and derived fluents
		ax 				: { interm-fluent, real };			// x acceleration of car
		ay 				: { interm-fluent, real };			// y acceleration of car
		dx				: { interm-fluent, real };			// x displacement of car
		dy				: { interm-fluent, real };			// y displacement of car
		
		o1(shape, boundary)			: { interm-fluent, int }; 			// orientations of line segments	
		o2(shape, boundary)			: { interm-fluent, int }; 			
		o3(shape, boundary)			: { interm-fluent, int }; 			
		o4(shape, boundary)			: { interm-fluent, int }; 					
		intersect(shape, boundary)	: { interm-fluent, bool }; 			// whether car crosses boundary of given shape
		violation		: { interm-fluent, bool };			// whether car crosses any boundary of any shape
		
		// states
       	x    	: { state-fluent, real, default = 0 };      // x position of car
		y 		: { state-fluent, real, default = 0 };		// y position of car
		vx		: { state-fluent, real, default = 0 };		// x velocity of car
		vy		: { state-fluent, real, default = 0 };		// y velocity of car
		
       	// actions
       	fx 		: { action-fluent, real, default = 0 };     // x force component applied to the car
		fy 		: { action-fluent, real, default = 0 };     // y force component applied to the car
    };

    cpfs {
	
		// compute acceleration and displacement of the car
		ax = fx / MASS;
		ay = fy / MASS;
		dx = vx * DT + ax * pow[DT, 2] / 2;
		dy = vy * DT + ay * pow[DT, 2] / 2;
				 
		// detect intersect with boundaries
		// ref: https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
		o1(?s, ?b) = sgn[(dy * (X1(?s, ?b) - (x + dx))) - (dx * (Y1(?s, ?b) - (y + dy)))];
		o2(?s, ?b) = sgn[(dy * (X2(?s, ?b) - (x + dx))) - (dx * (Y2(?s, ?b) - (y + dy)))];
		o3(?s, ?b) = sgn[((Y2(?s, ?b) - Y1(?s, ?b)) * (x - X2(?s, ?b))) - ((X2(?s, ?b) - X1(?s, ?b)) * (y - Y2(?s, ?b)))];
		o4(?s, ?b) = sgn[((Y2(?s, ?b) - Y1(?s, ?b)) * ((x + dx) - X2(?s, ?b))) - ((X2(?s, ?b) - X1(?s, ?b)) * ((y + dy) - Y2(?s, ?b)))];
		
		intersect(?s, ?b) = ((o1(?s, ?b) ~= o2(?s, ?b)) ^ (o3(?s, ?b) ~= o4(?s, ?b))) | 
							((o1(?s, ?b) == 0) ^ ((X1(?s, ?b) <= max[x, (x + dx)]) ^ (X1(?s, ?b) >= min[x, (x + dx)]) ^ 
												 (Y1(?s, ?b) <= max[y, (y + dy)]) ^ (Y1(?s, ?b) >= min[y, (y + dy)]))) | 
							((o2(?s, ?b) == 0) ^ ((X2(?s, ?b) <= max[x, (x + dx)]) ^ (X2(?s, ?b) >= min[x, (x + dx)]) ^ 
												 (Y2(?s, ?b) <= max[y, (y + dy)]) ^ (Y2(?s, ?b) >= min[y, (y + dy)]))) | 
						    ((o3(?s, ?b) == 0) ^ ((x <= max[X1(?s, ?b), X2(?s, ?b)]) ^ (x >= min[X1(?s, ?b), X2(?s, ?b)]) ^ 
										         (y <= max[Y1(?s, ?b), Y2(?s, ?b)]) ^ (y >= min[Y1(?s, ?b), Y2(?s, ?b)]))) | 
						    ((o4(?s, ?b) == 0) ^ (((x + dx) <= max[X1(?s, ?b), X2(?s, ?b)]) ^ ((x + dx) >= min[X1(?s, ?b), X2(?s, ?b)]) ^ 
										         ((y + dy) <= max[Y1(?s, ?b), Y2(?s, ?b)]) ^ ((y + dy) >= min[Y1(?s, ?b), Y2(?s, ?b)])));
		
		violation = exists_{?s: shape, ?b : boundary} [intersect(?s, ?b)];
		
		// compute new position and velocity
		x' = if(violation) 
				then X0
				else x + dx;				
		y' = if(violation)
				then Y0
				else y + dy;
		vx' = if(violation)
				then 0.0
				else vx + ax * DT;
		vy' = if(violation)
				then 0.0
				else vy + ay * DT;		
    };

    reward = (-COST * sqrt[pow[fx, 2] + pow[fy, 2]]) + 
				(if(sqrt[pow[x' - GX, 2] + pow[y' - GY, 2]] <= RADIUS)
					then GOAL-REWARD
					else 0.0);

	termination {
		sqrt[pow[x - GX, 2] + pow[y - GY, 2]] <= RADIUS;
	};
	
    state-invariants {
		RADIUS >= 0 ^ MAX-F >= 0 ^ MASS >= 0 ^ DT >= 0;
    };

    action-preconditions {
		fx >= -MAX-F;
		fx <= MAX-F;
		fy >= -MAX-F;
		fy <= MAX-F;
    };

}
